//  For licensing see accompanying LICENSE.md file.
//  Copyright ¬© 2025 Cription. All rights reserved.

import Foundation
import SwiftUI
import StoreKit

// MARK: - Spending Tier
enum SpendingTier: String, CaseIterable, Identifiable {
    case tier1 = "Tier 1"
    case tier2 = "Tier 2"
    case tier3 = "Tier 3"
    case tier4 = "Tier 4"
    case custom = "Custom"
    
    var id: String { rawValue }
    
    var monthlyLimit: Double {
        switch self {
        case .tier1:
            return 50.0
        case .tier2:
            return 500.0
        case .tier3:
            return 5000.0
        case .tier4:
            return 50000.0
        case .custom:
            return 0.0 // „Ç´„Çπ„Çø„É†„ÅØÂÄãÂà•Ë®≠ÂÆö
        }
    }
    
    var requiredHistoricalSpend: Double {
        switch self {
        case .tier1:
            return 0.0 // „Éá„Éï„Ç©„É´„Éà
        case .tier2:
            return 50.0
        case .tier3:
            return 500.0
        case .tier4:
            return 5000.0
        case .custom:
            return 0.0
        }
    }
    
    var requiredDaysSinceFirstPayment: Int {
        switch self {
        case .tier1:
            return 0 // Âç≥Â∫ß
        case .tier2:
            return 7
        case .tier3:
            return 14
        case .tier4:
            return 30
        case .custom:
            return 0
        }
    }
    
    var displayName: String {
        switch self {
        case .tier1:
            return String(localized: LocalizedStringResource("Tier 1", comment: "Spending tier 1 name"))
        case .tier2:
            return String(localized: LocalizedStringResource("Tier 2", comment: "Spending tier 2 name"))
        case .tier3:
            return String(localized: LocalizedStringResource("Tier 3", comment: "Spending tier 3 name"))
        case .tier4:
            return String(localized: LocalizedStringResource("Tier 4", comment: "Spending tier 4 name"))
        case .custom:
            return String(localized: LocalizedStringResource("Custom", comment: "Custom spending tier name"))
        }
    }
    
    var qualificationText: String {
        switch self {
        case .tier1:
            return String(localized: LocalizedStringResource("Default with valid payment method added", comment: "Tier 1 qualification"))
        case .tier2:
            return String(localized: LocalizedStringResource("Total historical spend of $50+ and 7 days since first payment", comment: "Tier 2 qualification"))
        case .tier3:
            return String(localized: LocalizedStringResource("Total historical spend of $500+ and 14 days since first payment", comment: "Tier 3 qualification"))
        case .tier4:
            return String(localized: LocalizedStringResource("Total historical spend of $5,000+ and 30 days since first payment", comment: "Tier 4 qualification"))
        case .custom:
            return String(localized: LocalizedStringResource("Contact support for custom limits", comment: "Custom tier qualification"))
        }
    }
    
    var canBuyCredits: Bool {
        switch self {
        case .tier1, .tier2, .tier3, .tier4:
            return true
        case .custom:
            return false
        }
    }
}

// MARK: - Tier System Manager
@MainActor
class TierSystemManager: ObservableObject {
    static let shared = TierSystemManager()
    
    @Published var currentTier: SpendingTier = .tier1
    @Published var currentMonthlySpend: Double = 0.0
    @Published var historicalSpend: Double = 0.0
    @Published var customLimit: Double = 0.0
    @Published var firstPaymentDate: Date?
    @Published var isLoading = false
    @Published var error: String?
    
    private let userDefaults = UserDefaults.standard
    private let secureDataManager = SecureTierDataManager.shared
    private let currentTierKey = "currentTier"
    private let customLimitKey = "customLimit"
    private let monthlySpendKey = "currentMonthlySpend"
    private let lastResetDateKey = "lastMonthlyReset"
    
    // StoreKit 2 TransactionÁõ£Ë¶ñ
    private var transactionListener: Task<Void, Error>?
    
    // Á´∂ÂêàÁä∂ÊÖã„ÇíÈò≤„Åê„Åü„ÇÅ„ÅÆ„Çª„Éû„Éï„Ç©
    private let dataAccessQueue = DispatchQueue(label: "com.cription.tiersystem.data", attributes: .concurrent)
    private let recalculationSemaphore = DispatchSemaphore(value: 1)
    
    private init() {
        loadData()
        startTransactionListener()
        checkMonthlyReset()
    }
    
    deinit {
        transactionListener?.cancel()
    }
    
    // MARK: - Data Management
    private func loadData() {
        // „Çª„Ç≠„É•„Ç¢„Å™„Éá„Éº„Çø„ÅÆÂæ©ÂÖÉ
        let recoveredData = secureDataManager.recoverData()
        historicalSpend = recoveredData.historicalSpend
        firstPaymentDate = recoveredData.firstPaymentDate
        
        // UserDefaults„Åã„ÇâÈùûÊ©üÂØÜ„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø
        customLimit = userDefaults.double(forKey: customLimitKey)
        currentMonthlySpend = userDefaults.double(forKey: monthlySpendKey)
        
        if let tierString = userDefaults.string(forKey: currentTierKey),
           let tier = SpendingTier(rawValue: tierString) {
            currentTier = tier
        }
        
        // StoreKit 2„Åã„ÇâÂ±•Ê≠¥ÊîØÂá∫„ÇíÂÜçË®àÁÆó
        Task {
            await recalculateHistoricalSpend()
        }
    }
    
    private func saveData() {
        // „Éá„Éº„ÇøÊï¥ÂêàÊÄß„Çí‰øùË®º„Åô„Çã„Åü„ÇÅ„ÅÆ„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥Âá¶ÁêÜ
        userDefaults.beginContentAccess()
        defer { userDefaults.endContentAccess() }
        
        do {
            // „Çª„Ç≠„É•„Ç¢„Å™„Éá„Éº„Çø„ÇíKeychain„Å´‰øùÂ≠ò
            guard secureDataManager.saveHistoricalSpend(historicalSpend) else {
                throw NSError(domain: "TierSystemManager", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to save historical spend to Keychain"])
            }
            
            if let firstPaymentDate = firstPaymentDate {
                guard secureDataManager.saveFirstPaymentDate(firstPaymentDate) else {
                    throw NSError(domain: "TierSystemManager", code: -2, userInfo: [NSLocalizedDescriptionKey: "Failed to save first payment date to Keychain"])
                }
            }
            
            // ÈùûÊ©üÂØÜ„Éá„Éº„Çø„ÇíUserDefaults„Å´‰øùÂ≠ò
            userDefaults.set(currentTier.rawValue, forKey: currentTierKey)
            userDefaults.set(customLimit, forKey: customLimitKey)
            userDefaults.set(currentMonthlySpend, forKey: monthlySpendKey)
            
            // „Éá„Éº„Çø„ÅÆÊï¥ÂêàÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
            guard secureDataManager.loadHistoricalSpend() == historicalSpend else {
                throw NSError(domain: "TierSystemManager", code: -3, userInfo: [NSLocalizedDescriptionKey: "Data integrity check failed for historical spend"])
            }
            
            guard userDefaults.string(forKey: currentTierKey) == currentTier.rawValue else {
                throw NSError(domain: "TierSystemManager", code: -4, userInfo: [NSLocalizedDescriptionKey: "Data integrity check failed for current tier"])
            }
            
            print("‚úÖ Data saved successfully with integrity check")
            
        } catch {
            print("‚ùå Failed to save data: \(error)")
            // „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„ÅüÂ†¥Âêà„ÅØ„ÄÅ„Éá„Éº„Çø„ÇíÂæ©ÂÖÉ„ÇíË©¶Ë°å
            loadData()
        }
    }
    
    // MARK: - StoreKit 2 Integration
    private func startTransactionListener() {
        transactionListener = Task.detached {
            for await result in Transaction.updates {
                do {
                    let transaction = try checkVerified(result)
                    await self.handleTransactionUpdate(transaction)
                } catch {
                    await MainActor.run {
                        self.error = "Transaction verification failed: \(error.localizedDescription)"
                    }
                    print("‚ùå Transaction verification failed: \(error)")
                }
            }
        }
    }
    
    private func handleTransactionUpdate(_ transaction: Transaction) async {
        guard transaction.revocationDate == nil else {
            // ËøîÈáë„Åï„Çå„ÅüÂ†¥Âêà„ÄÅÂ±•Ê≠¥ÊîØÂá∫„Åã„ÇâÂ∑Æ„ÅóÂºï„Åè
            await removeSpendingFromTransaction(transaction)
            return
        }
        
        guard transaction.revocationDate == nil else { return }
        
        // Êñ∞„Åó„ÅÑË≥ºÂÖ•„ÅÆÂ†¥Âêà„ÄÅÂ±•Ê≠¥ÊîØÂá∫„Å´ËøΩÂä†
        await addSpendingFromTransaction(transaction)
    }
    
    private func addSpendingFromTransaction(_ transaction: Transaction) async {
        let amount = await getTransactionAmount(transaction)
        
        // „Çπ„É¨„ÉÉ„Éâ„Çª„Éº„Éï„Å™Êõ¥Êñ∞
        await MainActor.run {
            // ÂàùÂõûÊîØÊâï„ÅÑÊó•„ÇíË®òÈå≤
            if self.firstPaymentDate == nil {
                self.firstPaymentDate = transaction.purchaseDate
            }
            
            self.historicalSpend += amount
            self.updateCurrentTier()
            self.saveData()
        }
        
        print("üí∞ Added $\(String(format: "%.2f", amount)) from transaction \(transaction.id) to historical spend. Total: $\(String(format: "%.2f", amount))")
    }
    
    private func removeSpendingFromTransaction(_ transaction: Transaction) async {
        let amount = await getTransactionAmount(transaction)
        
        // „Çπ„É¨„ÉÉ„Éâ„Çª„Éº„Éï„Å™Êõ¥Êñ∞
        await MainActor.run {
            self.historicalSpend = max(0, self.historicalSpend - amount)
            self.updateCurrentTier()
            self.saveData()
        }
        
        print("üí∏ Removed $\(String(format: "%.2f", amount)) from transaction \(transaction.id) from historical spend. Total: $\(String(format: "%.2f", amount))")
    }
    
    private func getTransactionAmount(_ transaction: Transaction) async -> Double {
        // „Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„ÅÆÈáëÈ°ç„ÇíÂèñÂæó
        // StoreKit 2„Åß„ÅØ„ÄÅtransaction.price„ÅØProduct.PriceÂûã
        // ÂÆüÈöõ„ÅÆÈáëÈ°ç„ÇíÂèñÂæó„Åô„Çã„Å´„ÅØ„ÄÅProduct„ÇíÂèñÂæó„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã
        
        do {
            let product = try await Product.products(for: [transaction.productID]).first
            if let product = product {
                // ‰æ°Ê†º„ÇíÂèñÂæóÔºàÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØ„ÄÅproduct.price„ÇíÈÅ©Âàá„Å´Â§âÊèõÔºâ
                return await getProductPrice(product)
            } else {
                await MainActor.run {
                    self.error = "Product not found for transaction: \(transaction.productID)"
                }
                print("‚ùå Product not found for transaction: \(transaction.productID)")
            }
        } catch {
            await MainActor.run {
                self.error = "Failed to get product for transaction: \(error.localizedDescription)"
            }
            print("‚ùå Failed to get product for transaction: \(error)")
        }
        
        return 0.0
    }
    
    private func getProductPrice(_ product: Product) async -> Double {
        // StoreKit 2„ÅÆ‰æ°Ê†ºÊÉÖÂ†±„Çí‰ΩøÁî®
        let price = product.price
        
        // ‰æ°Ê†º„ÇíDouble„Å´Â§âÊèõÔºàProduct.Price„Åã„ÇâÔºâ
        if let priceValue = Double(price.description) {
            return priceValue
        }
        
        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „ÇØ„É¨„Ç∏„ÉÉ„ÉàË≥ºÂÖ•„ÅÆ‰æ°Ê†º„Éû„ÉÉ„Éî„É≥„Ç∞
        let creditPrices: [String: Double] = [
            "Cription.credits.22": 19.99,
            "Cription.credits.55": 49.99,
            "Cription.credits.110": 99.99,
            "Cription.credits.220": 199.99,
            "Cription.credits.1100": 999.99
        ]
        
        // „Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Éó„É©„É≥„ÅÆ‰æ°Ê†º„Éû„ÉÉ„Éî„É≥„Ç∞
        let subscriptionPrices: [String: Double] = [
            "Cription.plus.weekly": 4.99,
            "Cription.plus.monthly": 19.99,
            "Cription.plus.yearly": 199.99
        ]
        
        // „É≠„Éº„Ç´„É´„É¢„Éá„É´„ÅÆ‰æ°Ê†º„Éû„ÉÉ„Éî„É≥„Ç∞
        let modelPrices: [String: Double] = [
            "Cription.model.whisper-large": 9.99,
            "Cription.model.whisper-medium": 4.99
        ]
        
        if let price = creditPrices[product.id] {
            return price
        } else if let price = subscriptionPrices[product.id] {
            return price
        } else if let price = modelPrices[product.id] {
            return price
        }
        
        // „Éá„Éï„Ç©„É´„Éà‰æ°Ê†ºÔºàÂÆüÈöõ„ÅÆ‰æ°Ê†º„ÅåÂèñÂæó„Åß„Åç„Å™„ÅÑÂ†¥ÂêàÔºâ
        return 0.0
    }
    
    // MARK: - Historical Spend Recalculation
    private func recalculateHistoricalSpend() async {
        // Á´∂ÂêàÁä∂ÊÖã„ÇíÈò≤„Åê„Åü„ÇÅ„ÅÆ„Çª„Éû„Éï„Ç©
        recalculationSemaphore.wait()
        defer { recalculationSemaphore.signal() }
        
        await MainActor.run {
            isLoading = true
            error = nil
        }
        defer { 
            Task { @MainActor in
                isLoading = false
            }
        }
        
        do {
            var totalSpend: Double = 0.0
            var earliestPaymentDate: Date?
            var transactionCount = 0
            
            // StoreKit 2„ÅÆTransaction.all„Çí‰ΩøÁî®„Åó„Å¶„Åô„Åπ„Å¶„ÅÆ„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥Â±•Ê≠¥„ÇíÂèñÂæó
            for await result in Transaction.all {
                do {
                    let transaction = try checkVerified(result)
                    transactionCount += 1
                    
                    // ËøîÈáë„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„ÅÆ„Åø
                    guard transaction.revocationDate == nil else { 
                        print("‚è≠Ô∏è Skipping revoked transaction: \(transaction.id)")
                        continue 
                    }
                    
                    let amount = await getTransactionAmount(transaction)
                    totalSpend += amount
                    
                    // ÊúÄÂàù„ÅÆÊîØÊâï„ÅÑÊó•„ÇíË®òÈå≤
                    if earliestPaymentDate == nil || transaction.purchaseDate < earliestPaymentDate! {
                        earliestPaymentDate = transaction.purchaseDate
                    }
                    
                    print("üí∞ Transaction \(transaction.id): $\(String(format: "%.2f", amount)) on \(transaction.purchaseDate)")
                    
                } catch {
                    print("‚ùå Transaction verification failed during recalculation: \(error)")
                }
            }
            
            // „Éá„Éº„Çø„ÇíÊõ¥Êñ∞Ôºà„Çπ„É¨„ÉÉ„Éâ„Çª„Éº„ÉïÔºâ
            await MainActor.run {
                self.historicalSpend = totalSpend
                if self.firstPaymentDate == nil {
                    self.firstPaymentDate = earliestPaymentDate
                }
                
                self.updateCurrentTier()
                self.saveData()
            }
            
            print("‚úÖ Recalculated historical spend: $\(String(format: "%.2f", totalSpend)) from \(transactionCount) transactions")
            
        } catch {
            await MainActor.run {
                self.error = "Failed to recalculate historical spend: \(error.localizedDescription)"
            }
            print("‚ùå Failed to recalculate historical spend: \(error)")
        }
    }
    
    // MARK: - Tier Management
    func updateCurrentTier() {
        let newTier = determineTierFromHistoricalSpend()
        if newTier != currentTier {
            currentTier = newTier
            saveData()
            print("üîÑ Tier updated to: \(currentTier.displayName)")
        }
    }
    
    private func determineTierFromHistoricalSpend() -> SpendingTier {
        // „Ç®„ÉÉ„Ç∏„Ç±„Éº„Çπ„ÅÆÂá¶ÁêÜ
        guard historicalSpend.isFinite && historicalSpend >= 0 else {
            print("‚ö†Ô∏è Invalid historical spend: \(historicalSpend), defaulting to Tier 1")
            return .tier1
        }
        
        let daysSinceFirstPayment = getDaysSinceFirstPayment()
        
        // OpenAI Tier SystemÊ∫ñÊã†„ÅÆÂà§ÂÆö„É≠„Ç∏„ÉÉ„ÇØ
        // Tier 4: $5,000+ „Åã„Å§ 30Êó•‰ª•‰∏ä
        if historicalSpend >= SpendingTier.tier4.requiredHistoricalSpend && 
           daysSinceFirstPayment >= SpendingTier.tier4.requiredDaysSinceFirstPayment {
            return .tier4
        }
        
        // Tier 3: $500+ „Åã„Å§ 14Êó•‰ª•‰∏ä
        if historicalSpend >= SpendingTier.tier3.requiredHistoricalSpend && 
           daysSinceFirstPayment >= SpendingTier.tier3.requiredDaysSinceFirstPayment {
            return .tier3
        }
        
        // Tier 2: $50+ „Åã„Å§ 7Êó•‰ª•‰∏ä
        if historicalSpend >= SpendingTier.tier2.requiredHistoricalSpend && 
           daysSinceFirstPayment >= SpendingTier.tier2.requiredDaysSinceFirstPayment {
            return .tier2
        }
        
        // Tier 1: „Éá„Éï„Ç©„É´„ÉàÔºàÊúâÂäπ„Å™ÊîØÊâï„ÅÑÊñπÊ≥ïËøΩÂä†Ê∏à„ÅøÔºâ
        return .tier1
    }
    
    private func getDaysSinceFirstPayment() -> Int {
        guard let firstPaymentDate = firstPaymentDate else { return 0 }
        
        // „Ç®„ÉÉ„Ç∏„Ç±„Éº„Çπ„ÅÆÂá¶ÁêÜ
        let calendar = Calendar.current
        let now = Date()
        
        // Êú™Êù•„ÅÆÊó•‰ªò„ÅÆÂ†¥Âêà„ÅØ0„ÇíËøî„Åô
        if firstPaymentDate > now {
            print("‚ö†Ô∏è First payment date is in the future: \(firstPaymentDate)")
            return 0
        }
        
        // Êó•‰ªòË®àÁÆó
        let components = calendar.dateComponents([.day], from: firstPaymentDate, to: now)
        let days = components.day ?? 0
        
        // Áï∞Â∏∏„Å™ÂÄ§„ÅÆÂ†¥Âêà„ÅØ0„ÇíËøî„Åô
        guard days >= 0 && days <= 36500 else { // 100Âπ¥„ÇíË∂Ö„Åà„ÇãÂ†¥Âêà„ÅØÁï∞Â∏∏
            print("‚ö†Ô∏è Invalid days since first payment: \(days)")
            return 0
        }
        
        return days
    }
    
    // MARK: - Monthly Reset
    private func checkMonthlyReset() {
        let calendar = Calendar.current
        let now = Date()
        
        if let lastResetDate = userDefaults.object(forKey: lastResetDateKey) as? Date {
            // „Ç®„ÉÉ„Ç∏„Ç±„Éº„Çπ„ÅÆÂá¶ÁêÜ
            // Êú™Êù•„ÅÆÊó•‰ªò„ÅÆÂ†¥Âêà„ÅØÁèæÂú®ÊôÇÂàª„Åß„É™„Çª„ÉÉ„Éà
            if lastResetDate > now {
                print("‚ö†Ô∏è Last reset date is in the future, resetting now")
                resetMonthlySpend()
                return
            }
            
            // Áï∞Â∏∏„Å´Âè§„ÅÑÊó•‰ªò„ÅÆÂ†¥Âêà„ÅØÁèæÂú®ÊôÇÂàª„Åß„É™„Çª„ÉÉ„Éà
            let oneYearAgo = calendar.date(byAdding: .year, value: -1, to: now)!
            if lastResetDate < oneYearAgo {
                print("‚ö†Ô∏è Last reset date is too old, resetting now")
                resetMonthlySpend()
                return
            }
            
            // ÂâçÂõû„ÅÆ„É™„Çª„ÉÉ„Éà„Åã„Çâ1„É∂ÊúàÁµåÈÅé„Åó„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if let nowMonthStart = calendar.dateInterval(of: .month, for: now)?.start,
               let lastMonthStart = calendar.dateInterval(of: .month, for: lastResetDate)?.start {
                if nowMonthStart != lastMonthStart {
                    resetMonthlySpend()
                }
            } else {
                // Êó•‰ªòË®àÁÆó„Å´Â§±Êïó„Åó„ÅüÂ†¥Âêà„ÅØÂÆâÂÖ®„ÅÆ„Åü„ÇÅ„É™„Çª„ÉÉ„Éà
                print("‚ö†Ô∏è Failed to calculate month intervals, resetting")
                resetMonthlySpend()
            }
        } else {
            // ÂàùÂõûÂÆüË°åÊôÇ„ÅØ„É™„Çª„ÉÉ„Éà
            resetMonthlySpend()
        }
    }
    
    private func resetMonthlySpend() {
        currentMonthlySpend = 0.0
        userDefaults.set(currentMonthlySpend, forKey: monthlySpendKey)
        userDefaults.set(Date(), forKey: lastResetDateKey)
        print("üîÑ Monthly spend reset to $0.00")
    }
    
    // MARK: - Spending Management
    func addSpending(_ amount: Double) {
        // „Éá„Éº„ÇøÊ§úË®º
        guard amount >= 0 else {
            error = "Invalid spending amount: negative values are not allowed"
            print("‚ùå Invalid spending amount: \(amount)")
            return
        }
        
        guard amount <= 1000000.0 else {
            error = "Invalid spending amount: amount exceeds maximum limit"
            print("‚ùå Invalid spending amount: \(amount) exceeds maximum limit")
            return
        }
        
        guard amount.isFinite else {
            error = "Invalid spending amount: non-finite values are not allowed"
            print("‚ùå Invalid spending amount: non-finite value \(amount)")
            return
        }
        
        // Âà∂Èôê„ÉÅ„Çß„ÉÉ„ÇØ
        guard canSpend(amount) else {
            error = "Spending limit exceeded: cannot spend $\(String(format: "%.2f", amount))"
            print("‚ùå Spending limit exceeded: \(amount)")
            return
        }
        
        // „Çπ„É¨„ÉÉ„Éâ„Çª„Éº„Éï„Å™Êõ¥Êñ∞
        dataAccessQueue.async(flags: .barrier) {
            self.currentMonthlySpend += amount
            self.saveData()
        }
        
        error = nil // „Ç®„É©„Éº„Çí„ÇØ„É™„Ç¢
        print("üí∏ Added $\(String(format: "%.2f", amount)) to monthly spend. Total: $\(String(format: "%.2f", currentMonthlySpend))")
    }
    
    func resetMonthlySpend() {
        currentMonthlySpend = 0.0
        saveData()
    }
    
    // MARK: - Limit Checking
    func canSpend(_ amount: Double) -> Bool {
        let limit = getCurrentLimit()
        return (currentMonthlySpend + amount) <= limit
    }
    
    func getCurrentLimit() -> Double {
        if currentTier == .custom {
            return customLimit
        }
        return currentTier.monthlyLimit
    }
    
    func getRemainingLimit() -> Double {
        return max(0, getCurrentLimit() - currentMonthlySpend)
    }
    
    // MARK: - Tier Information
    func getAvailableTiers() -> [SpendingTier] {
        return SpendingTier.allCases.filter { tier in
            if tier == .custom {
                return true // „Ç´„Çπ„Çø„É†„ÅØÂ∏∏„Å´Ë°®Á§∫
            }
            return historicalSpend >= tier.requiredHistoricalSpend
        }
    }
    
    func getNextTier() -> SpendingTier? {
        let allTiers = SpendingTier.allCases.filter { $0 != .custom }
        let currentIndex = allTiers.firstIndex(of: currentTier)
        
        if let index = currentIndex, index < allTiers.count - 1 {
            return allTiers[index + 1]
        }
        return nil
    }
    
    func getRequiredSpendForNextTier() -> Double? {
        guard let nextTier = getNextTier() else { return nil }
        return max(0, nextTier.requiredHistoricalSpend - historicalSpend)
    }
    
    func getRequiredDaysForNextTier() -> Int? {
        guard let nextTier = getNextTier() else { return nil }
        let daysSinceFirstPayment = getDaysSinceFirstPayment()
        return max(0, nextTier.requiredDaysSinceFirstPayment - daysSinceFirstPayment)
    }
    
    // MARK: - Custom Limit Management
    func setCustomLimit(_ limit: Double) {
        // „Éá„Éº„ÇøÊ§úË®º
        guard limit >= 0 else {
            error = "Invalid custom limit: negative values are not allowed"
            print("‚ùå Invalid custom limit: \(limit)")
            return
        }
        
        guard limit <= 1000000.0 else {
            error = "Invalid custom limit: limit exceeds maximum allowed value"
            print("‚ùå Invalid custom limit: \(limit) exceeds maximum")
            return
        }
        
        guard limit.isFinite else {
            error = "Invalid custom limit: non-finite values are not allowed"
            print("‚ùå Invalid custom limit: non-finite value \(limit)")
            return
        }
        
        customLimit = limit
        currentTier = .custom
        saveData()
        error = nil // „Ç®„É©„Éº„Çí„ÇØ„É™„Ç¢
        print("‚úÖ Custom limit set to $\(String(format: "%.2f", limit))")
    }
    
    func clearCustomLimit() {
        customLimit = 0.0
        updateCurrentTier()
        saveData()
    }
    
    // MARK: - Credit Purchase
    func purchaseCredits(_ amount: Double) async throws {
        // StoreKit 2„Çí‰ΩøÁî®„Åó„Å¶„ÇØ„É¨„Ç∏„ÉÉ„Éà„ÇíË≥ºÂÖ•
        // ÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØ„ÄÅProduct„ÇíÂèñÂæó„Åó„Å¶Ë≥ºÂÖ•Âá¶ÁêÜ„ÇíË°å„ÅÜ
        let productID = getCreditProductID(for: amount)
        
        do {
            let products = try await Product.products(for: [productID])
            guard let product = products.first else {
                throw TierSystemError.productNotFound
            }
            
            let result = try await product.purchase()
            
            switch result {
            case .success(let verification):
                let transaction = try checkVerified(verification)
                await transaction.finish()
                
                // Ë≥ºÂÖ•ÊàêÂäüÊôÇ„ÅØËá™ÂãïÁöÑ„Å´Transaction.updates„ÅßÂá¶ÁêÜ„Åï„Çå„Çã
                print("‚úÖ Credit purchase successful: $\(String(format: "%.2f", amount))")
                
            case .userCancelled:
                throw TierSystemError.userCancelled
            case .pending:
                throw TierSystemError.pending
            @unknown default:
                throw TierSystemError.unknown
            }
            
        } catch {
            print("‚ùå Credit purchase failed: \(error)")
            throw error
        }
    }
    
    private func getCreditProductID(for amount: Double) -> String {
        // ÈáëÈ°ç„Å´Âü∫„Å•„ÅÑ„Å¶ÈÅ©Âàá„Å™„ÇØ„É¨„Ç∏„ÉÉ„ÉàÂïÜÂìÅID„ÇíËøî„Åô
        switch amount {
        case 0..<25:
            return "Cription.credits.22"
        case 25..<75:
            return "Cription.credits.55"
        case 75..<150:
            return "Cription.credits.110"
        case 150..<500:
            return "Cription.credits.220"
        default:
            return "Cription.credits.1100"
        }
    }
    
    // MARK: - Manual Refresh
    func refreshData() async {
        await recalculateHistoricalSpend()
    }
}

// MARK: - StoreKit 2 Helper
private func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {
    switch result {
    case .unverified:
        throw StoreError.failedVerification
    case .verified(let safe):
        return safe
    }
}

enum StoreError: Error {
    case failedVerification
}

enum TierSystemError: LocalizedError {
    case productNotFound
    case userCancelled
    case pending
    case unknown
    case invalidAmount
    case purchaseFailed
    
    var errorDescription: String? {
        switch self {
        case .productNotFound:
            return "Product not found"
        case .userCancelled:
            return "Purchase was cancelled by user"
        case .pending:
            return "Purchase is pending approval"
        case .unknown:
            return "An unknown error occurred"
        case .invalidAmount:
            return "Invalid purchase amount"
        case .purchaseFailed:
            return "Purchase failed"
        }
    }
}
